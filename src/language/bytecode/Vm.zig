const std = @import("std");

const ast = @import("../ast.zig");
const builtins = @import("../../builtins.zig");
const execution = @import("../../execution.zig");
const instructions_ = @import("instructions.zig");
const types = @import("../../types.zig");
const utils = @import("../../utils.zig");

const Agent = execution.Agent;
const ArgumentsList = builtins.ArgumentsList;
const BigInt = types.BigInt;
const Completion = types.Completion;
const Executable = @import("Executable.zig");
const Instruction = instructions_.Instruction;
const Object = types.Object;
const PropertyDescriptor = types.PropertyDescriptor;
const PropertyKey = types.PropertyKey;
const Reference = types.Reference;
const String = types.String;
const Value = types.Value;
const arrayCreate = builtins.arrayCreate;
const defineMethodProperty = builtins.defineMethodProperty;
const isLessThan = types.isLessThan;
const isLooselyEqual = types.isLooselyEqual;
const isStrictlyEqual = types.isStrictlyEqual;
const makeConstructor = builtins.makeConstructor;
const makeMethod = builtins.makeMethod;
const newDeclarativeEnvironment = execution.newDeclarativeEnvironment;
const noexcept = utils.noexcept;
const ordinaryFunctionCreate = builtins.ordinaryFunctionCreate;
const ordinaryObjectCreate = builtins.ordinaryObjectCreate;
const performEval = builtins.performEval;
const setFunctionName = builtins.setFunctionName;

const Self = @This();

agent: *Agent,
ip: usize,
stack: std.ArrayList(Value),
reference_stack: std.ArrayList(?Reference),
exception_jump_target_stack: std.ArrayList(usize),
result: ?Value = null,
exception: ?Value = null,
reference: ?Reference = null,

pub fn init(agent: *Agent) !Self {
    var stack = try std.ArrayList(Value).initCapacity(agent.gc_allocator, 32);
    var reference_stack = std.ArrayList(?Reference).init(agent.gc_allocator);
    var exception_jump_target_stack = std.ArrayList(usize).init(agent.gc_allocator);
    return .{
        .agent = agent,
        .ip = 0,
        .stack = stack,
        .reference_stack = reference_stack,
        .exception_jump_target_stack = exception_jump_target_stack,
    };
}

pub fn deinit(self: Self) void {
    self.stack.deinit();
    self.reference_stack.deinit();
    self.exception_jump_target_stack.deinit();
}

fn fetchInstruction(self: *Self, executable: Executable) ?Instruction {
    const instructions = executable.instructions.items;
    if (self.ip >= instructions.len) return null;
    defer self.ip += 1;
    return instructions[self.ip];
}

fn fetchConstant(self: *Self, executable: Executable) Value {
    const constants = executable.constants.items;
    const index = self.fetchIndex(executable);
    return constants[index];
}

fn fetchIdentifier(self: *Self, executable: Executable) []const u8 {
    const identifiers = executable.identifiers.items;
    const index = self.fetchIndex(executable);
    return identifiers[index];
}

fn fetchFunctionExpression(self: *Self, executable: Executable) Executable.FunctionExpression {
    const function_expressions = executable.function_expressions.items;
    const index = self.fetchIndex(executable);
    return function_expressions[index];
}

fn fetchIndex(self: *Self, executable: Executable) Executable.IndexType {
    const b1 = @intFromEnum(self.fetchInstruction(executable).?);
    const b2 = @intFromEnum(self.fetchInstruction(executable).?);
    return std.mem.bytesToValue(Executable.IndexType, &[_]u8{ b1, b2 });
}

/// 13.3.5.1.1 EvaluateNew ( constructExpr, arguments )
/// https://tc39.es/ecma262/#sec-evaluatenew
fn evaluateNew(agent: *Agent, constructor: Value, arguments: []const Value) !Value {
    // 1. Let ref be ? Evaluation of constructExpr.
    // 2. Let constructor be ? GetValue(ref).
    // 3. If arguments is empty, then
    //     a. Let argList be a new empty List.
    // 4. Else,
    //     a. Let argList be ? ArgumentListEvaluation of arguments.
    // NOTE: This is part of the generated bytecode.

    // 5. If IsConstructor(constructor) is false, throw a TypeError exception.
    if (!constructor.isConstructor()) {
        return agent.throwException(
            .type_error,
            try std.fmt.allocPrint(agent.gc_allocator, "{} is not a constructor", .{constructor}),
        );
    }

    // 6. Return ? Construct(constructor, argList).
    return Value.from(try constructor.object.construct(arguments, null));
}

/// 13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )
/// https://tc39.es/ecma262/#sec-evaluatecall
fn evaluateCallGetThisValue(maybe_reference: ?Reference) Value {
    // 1. If ref is a Reference Record, then
    if (maybe_reference) |reference| {
        // a. If IsPropertyReference(ref) is true, then
        if (reference.isPropertyReference()) {
            // i. Let thisValue be GetThisValue(ref).
            return reference.getThisValue();
        }
        // b. Else,
        else {
            // i. Let refEnv be ref.[[Base]].
            // ii. Assert: refEnv is an Environment Record.
            const reference_environment = reference.base.environment;

            // iii. Let thisValue be refEnv.WithBaseObject().
            return if (reference_environment.withBaseObject()) |object|
                Value.from(object)
            else
                .undefined;
        }
    }
    // 2. Else,
    else {
        // a. Let thisValue be undefined.
        return .undefined;
    }
}

/// 13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )
/// https://tc39.es/ecma262/#sec-evaluatecall
fn evaluateCall(
    agent: *Agent,
    function: Value,
    this_value: Value,
    arguments: []const Value,
) !Value {
    // 1-2.
    // NOTE: These are done in the function above, which is called by the prepare_call instruction.

    // 3. Let argList be ? ArgumentListEvaluation of arguments.
    // NOTE: This is part of the generated bytecode.

    // 4. If func is not an Object, throw a TypeError exception.
    if (function != .object) {
        return agent.throwException(
            .type_error,
            try std.fmt.allocPrint(agent.gc_allocator, "{} is not an Object", .{function}),
        );
    }

    // 5. If IsCallable(func) is false, throw a TypeError exception.
    if (!function.isCallable()) {
        return agent.throwException(
            .type_error,
            try std.fmt.allocPrint(agent.gc_allocator, "{} is not callable", .{function}),
        );
    }

    // TODO: 6. If tailPosition is true, perform PrepareForTailCall().

    // 7. Return ? Call(func, thisValue, argList).
    return function.callAssumeCallable(this_value, arguments);
}

/// CallExpression : CoverCallExpressionAndAsyncArrowHead
/// Step 6.a.
fn directEval(agent: *Agent, arguments: []const Value, strict: bool) !Value {
    // i. Let argList be ? ArgumentListEvaluation of arguments.
    // NOTE: This is part of the generated bytecode.

    // ii. If argList has no elements, return undefined.
    if (arguments.len == 0) return .undefined;

    // iii. Let evalArg be the first element of argList.
    const eval_arg = arguments[0];

    // iv. If the source text matched by this CallExpression is strict mode code, let strictCaller
    //     be true. Otherwise let strictCaller be false.
    const strict_caller = strict;

    // v. Return ? PerformEval(evalArg, strictCaller, true).
    return performEval(agent, eval_arg, strict_caller, true);
}

/// 13.10.2 InstanceofOperator ( V, target )
/// https://tc39.es/ecma262/#sec-instanceofoperator
fn instanceofOperator(agent: *Agent, value: Value, target: Value) !bool {
    // 1. If target is not an Object, throw a TypeError exception.
    if (target != .object) {
        return agent.throwException(
            .type_error,
            "Right-hand side of 'in' operator must be an object",
        );
    }

    // 2. Let instOfHandler be ? GetMethod(target, @@hasInstance).
    const maybe_instanceof_handler = try target.getMethod(
        agent,
        PropertyKey.from(agent.well_known_symbols.@"@@hasInstance"),
    );

    // 3. If instOfHandler is not undefined, then
    if (maybe_instanceof_handler) |instanceof_handler| {
        // a. Return ToBoolean(? Call(instOfHandler, target, Â« V Â»)).
        return (try Value.from(instanceof_handler).call(agent, target, .{value})).toBoolean();
    }

    // 4. If IsCallable(target) is false, throw a TypeError exception.
    if (!target.isCallable()) {
        return agent.throwException(
            .type_error,
            try std.fmt.allocPrint(agent.gc_allocator, "{} is not callable", .{target}),
        );
    }

    // 5. Return ? OrdinaryHasInstance(target, V).
    return target.ordinaryHasInstance(value);
}

/// 13.15.3 ApplyStringOrNumericBinaryOperator ( lval, opText, rval )
/// https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator
fn applyStringOrNumericBinaryOperator(agent: *Agent, lval: Value, operator: ast.BinaryExpression.Operator, rval: Value) !Value {
    var final_lval = lval;
    var final_rval = rval;

    // 1. If opText is +, then
    if (operator == .@"+") {
        // a. Let lprim be ? ToPrimitive(lval).
        const lprim = try lval.toPrimitive(agent, null);

        // b. Let rprim be ? ToPrimitive(rval).
        const rprim = try rval.toPrimitive(agent, null);

        // c. If lprim is a String or rprim is a String, then
        if (lprim == .string or rprim == .string) {
            // i. Let lstr be ? ToString(lprim).
            const lstr = try lprim.toString(agent);

            // ii. Let rstr be ? ToString(rprim).
            const rstr = try rprim.toString(agent);

            // iii. Return the string-concatenation of lstr and rstr.
            // TODO: Implement rope strings
            return Value.from(
                try std.mem.concat(agent.gc_allocator, u8, &.{ lstr.utf8, rstr.utf8 }),
            );
        }

        // d. Set lval to lprim.
        final_lval = lprim;

        // e. Set rval to rprim.
        final_rval = rprim;
    }

    // 2. NOTE: At this point, it must be a numeric operation.

    // 3. Let lnum be ? ToNumeric(lval).
    const lnum = try final_lval.toNumeric(agent);

    // 4. Let rnum be ? ToNumeric(rval).
    const rnum = try final_rval.toNumeric(agent);

    // 5. If Type(lnum) is not Type(rnum), throw a TypeError exception.
    if (std.meta.activeTag(lnum) != std.meta.activeTag(rnum)) {
        return agent.throwException(
            .type_error,
            "Left-hand side and right-hand side of numeric binary expression must have the same type",
        );
    }

    // 6. If lnum is a BigInt, then
    if (lnum == .big_int) switch (operator) {
        // a. If opText is **, return ? BigInt::exponentiate(lnum, rnum).
        .@"**" => return Value.from(try lnum.big_int.exponentiate(agent, rnum.big_int)),

        // b. If opText is /, return ? BigInt::divide(lnum, rnum).
        .@"/" => return Value.from(try lnum.big_int.divide(agent, rnum.big_int)),

        // c. If opText is %, return ? BigInt::remainder(lnum, rnum).
        .@"%" => return Value.from(try lnum.big_int.remainder(agent, rnum.big_int)),

        // d. If opText is >>>, return ? BigInt::unsignedRightShift(lnum, rnum).
        .@">>>" => return Value.from(try lnum.big_int.unsignedRightShift(agent, rnum.big_int)),

        else => {},
    };

    // 7. Let operation be the abstract operation associated with opText and Type(lnum) in the following table:
    // 8. Return operation(lnum, rnum).
    switch (operator) {
        .@"**" => return Value.from(lnum.number.exponentiate(rnum.number)),
        .@"*" => switch (lnum) {
            .number => return Value.from(lnum.number.multiply(rnum.number)),
            .big_int => return Value.from(try lnum.big_int.multiply(agent, rnum.big_int)),
        },
        .@"/" => return Value.from(lnum.number.divide(rnum.number)),
        .@"%" => return Value.from(lnum.number.remainder(rnum.number)),
        .@"+" => switch (lnum) {
            .number => return Value.from(lnum.number.add(rnum.number)),
            .big_int => return Value.from(try lnum.big_int.add(agent, rnum.big_int)),
        },
        .@"-" => switch (lnum) {
            .number => return Value.from(lnum.number.subtract(rnum.number)),
            .big_int => return Value.from(try lnum.big_int.subtract(agent, rnum.big_int)),
        },
        .@"<<" => switch (lnum) {
            .number => return Value.from(lnum.number.leftShift(rnum.number)),
            .big_int => return Value.from(try lnum.big_int.leftShift(agent, rnum.big_int)),
        },
        .@">>" => switch (lnum) {
            .number => return Value.from(lnum.number.signedRightShift(rnum.number)),
            .big_int => return Value.from(try lnum.big_int.signedRightShift(agent, rnum.big_int)),
        },
        .@">>>" => return Value.from(lnum.number.unsignedRightShift(rnum.number)),
        .@"&" => switch (lnum) {
            .number => return Value.from(lnum.number.bitwiseAND(rnum.number)),
            .big_int => return Value.from(try lnum.big_int.bitwiseAND(agent, rnum.big_int)),
        },
        .@"^" => switch (lnum) {
            .number => return Value.from(lnum.number.bitwiseXOR(rnum.number)),
            .big_int => return Value.from(try lnum.big_int.bitwiseXOR(agent, rnum.big_int)),
        },
        .@"|" => switch (lnum) {
            .number => return Value.from(lnum.number.bitwiseOR(rnum.number)),
            .big_int => return Value.from(try lnum.big_int.bitwiseOR(agent, rnum.big_int)),
        },
    }
}

/// 15.2.5 Runtime Semantics: InstantiateOrdinaryFunctionExpression
/// https://tc39.es/ecma262/#sec-runtime-semantics-instantiateordinaryfunctionexpression
fn instantiateOrdinaryFunctionExpression(
    agent: *Agent,
    function_expression: ast.FunctionExpression,
    default_name: ?[]const u8,
) !Object {
    const realm = agent.currentRealm();

    // FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
    if (function_expression.identifier) |identifier| {
        // 1. Assert: name is not present.
        std.debug.assert(default_name == null);

        // 2. Set name to StringValue of BindingIdentifier.
        const name = identifier;

        // 3. Let outerEnv be the running execution context's LexicalEnvironment.
        const outer_env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

        // 4. Let funcEnv be NewDeclarativeEnvironment(outerEnv).
        const func_env = try newDeclarativeEnvironment(agent.gc_allocator, outer_env);

        // 5. Perform ! funcEnv.CreateImmutableBinding(name, false).
        try func_env.createImmutableBinding(agent, name, false);

        // 6. Let privateEnv be the running execution context's PrivateEnvironment.
        const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

        // 7. Let sourceText be the source text matched by FunctionExpression.
        const source_text = function_expression.source_text;

        // 8. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText,
        //    FormalParameters, FunctionBody, non-lexical-this, funcEnv, privateEnv).
        const closure = try ordinaryFunctionCreate(
            agent,
            try realm.intrinsics.@"%Function.prototype%"(),
            source_text,
            function_expression.formal_parameters,
            function_expression.function_body,
            .non_lexical_this,
            .{ .declarative_environment = func_env },
            private_env,
        );

        // 9. Perform SetFunctionName(closure, name).
        try setFunctionName(closure, PropertyKey.from(name), null);

        // 10. Perform MakeConstructor(closure).
        try makeConstructor(closure, .{});

        // 11. Perform ! funcEnv.InitializeBinding(name, closure).
        func_env.initializeBinding(agent, name, Value.from(closure));

        // 12. Return closure.
        return closure;
    }
    // FunctionExpression : function ( FormalParameters ) { FunctionBody }
    else {
        // 1. If name is not present, set name to "".
        const name = default_name orelse "";

        // 2. Let env be the LexicalEnvironment of the running execution context.
        const env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

        // 3. Let privateEnv be the running execution context's PrivateEnvironment.
        const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

        // 4. Let sourceText be the source text matched by FunctionExpression.
        const source_text = function_expression.source_text;

        // 5. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText,
        //    FormalParameters, FunctionBody, non-lexical-this, env, privateEnv).
        const closure = try ordinaryFunctionCreate(
            agent,
            try realm.intrinsics.@"%Function.prototype%"(),
            source_text,
            function_expression.formal_parameters,
            function_expression.function_body,
            .non_lexical_this,
            env,
            private_env,
        );

        // 6. Perform SetFunctionName(closure, name).
        try setFunctionName(closure, PropertyKey.from(name), null);

        // 7. Perform MakeConstructor(closure).
        try makeConstructor(closure, .{});

        // 8. Return closure.
        return closure;
    }
}

/// 15.3.4 Runtime Semantics: InstantiateArrowFunctionExpression
/// https://tc39.es/ecma262/#sec-runtime-semantics-instantiatearrowfunctionexpression
fn instantiateArrowFunctionExpression(
    agent: *Agent,
    arrow_function: ast.ArrowFunction,
    default_name: ?[]const u8,
) !Object {
    const realm = agent.currentRealm();

    // 1. If name is not present, set name to "".
    const name = default_name orelse "";

    // 2. Let env be the LexicalEnvironment of the running execution context.
    const env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

    // 3. Let privateEnv be the running execution context's PrivateEnvironment.
    const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

    // 4. Let sourceText be the source text matched by ArrowFunction.
    const source_text = arrow_function.source_text;

    // 5. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, ArrowParameters,
    //    ConciseBody, lexical-this, env, privateEnv).
    const closure = try ordinaryFunctionCreate(
        agent,
        try realm.intrinsics.@"%Function.prototype%"(),
        source_text,
        arrow_function.formal_parameters,
        arrow_function.function_body,
        .lexical_this,
        env,
        private_env,
    );

    // 6. Perform SetFunctionName(closure, name).
    try setFunctionName(closure, PropertyKey.from(name), null);

    // 7. Return closure.
    return closure;
}

/// 15.4.4 Runtime Semantics: DefineMethod
/// https://tc39.es/ecma262/#sec-runtime-semantics-definemethod
fn defineMethod(
    agent: *Agent,
    function_expression: ast.FunctionExpression,
    property_name: Value,
    object: Object,
    function_prototype: ?Object,
) !struct { key: PropertyKey, closure: Object } {
    const realm = agent.currentRealm();

    // 1. Let propKey be ? Evaluation of ClassElementName.
    const property_key = try property_name.toPropertyKey(agent);

    // 2. Let env be the running execution context's LexicalEnvironment.
    const env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

    // 3. Let privateEnv be the running execution context's PrivateEnvironment.
    const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

    // 4. If functionPrototype is present, then
    //     a. Let prototype be functionPrototype.
    // 5. Else,
    //     a. Let prototype be %Function.prototype%.
    const prototype = function_prototype orelse try realm.intrinsics.@"%Function.prototype%"();

    // 6. Let sourceText be the source text matched by MethodDefinition.
    const source_text = function_expression.source_text;

    // 7. Let closure be OrdinaryFunctionCreate(prototype, sourceText, UniqueFormalParameters,
    //    FunctionBody, non-lexical-this, env, privateEnv).
    const closure = try ordinaryFunctionCreate(
        agent,
        prototype,
        source_text,
        function_expression.formal_parameters,
        function_expression.function_body,
        .non_lexical_this,
        env,
        private_env,
    );

    // 8. Perform MakeMethod(closure, object).
    makeMethod(closure.as(builtins.ECMAScriptFunction), object);

    // 9. Return the Record { [[Key]]: propKey, [[Closure]]: closure }.
    return .{ .key = property_key, .closure = closure };
}

/// 15.5.4 Runtime Semantics: InstantiateGeneratorFunctionExpression
/// https://tc39.es/ecma262/#sec-runtime-semantics-instantiategeneratorfunctionexpression
fn instantiateGeneratorFunctionExpression(
    agent: *Agent,
    generator_expression: ast.GeneratorExpression,
    default_name: ?[]const u8,
) !Object {
    const realm = agent.currentRealm();

    // GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
    if (generator_expression.identifier) |identifier| {
        // 1. Assert: name is not present.
        std.debug.assert(default_name == null);

        // 2. Set name to StringValue of BindingIdentifier.
        const name = identifier;

        // 3. Let outerEnv be the running execution context's LexicalEnvironment.
        const outer_env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

        // 4. Let funcEnv be NewDeclarativeEnvironment(outerEnv).
        const func_env = try newDeclarativeEnvironment(agent.gc_allocator, outer_env);

        // 5. Perform ! funcEnv.CreateImmutableBinding(name, false).
        try func_env.createImmutableBinding(agent, name, false);

        // 6. Let privateEnv be the running execution context's PrivateEnvironment.
        const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

        // 7. Let sourceText be the source text matched by GeneratorExpression.
        const source_text = generator_expression.source_text;

        // 8. Let closure be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
        //    FormalParameters, GeneratorBody, non-lexical-this, funcEnv, privateEnv).
        const closure = try ordinaryFunctionCreate(
            agent,
            try realm.intrinsics.@"%GeneratorFunction.prototype%"(),
            source_text,
            generator_expression.formal_parameters,
            generator_expression.function_body,
            .non_lexical_this,
            .{ .declarative_environment = func_env },
            private_env,
        );

        // 9. Perform SetFunctionName(closure, name).
        try setFunctionName(closure, PropertyKey.from(name), null);

        // 10. Let prototype be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
        const prototype = try ordinaryObjectCreate(
            agent,
            try realm.intrinsics.@"%GeneratorFunction.prototype.prototype%"(),
        );

        // 11. Perform ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor {
        //       [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false
        //     }).
        closure.definePropertyOrThrow(PropertyKey.from("prototype"), .{
            .value = Value.from(prototype),
            .writable = true,
            .enumerable = false,
            .configurable = false,
        }) catch |err| try noexcept(err);

        // 12. Perform ! funcEnv.InitializeBinding(name, closure).
        func_env.initializeBinding(agent, name, Value.from(closure));

        // 13. Return closure.
        return closure;
    }
    // GeneratorExpression : function * ( FormalParameters ) { GeneratorBody }
    else {
        // 1. If name is not present, set name to "".
        const name = default_name orelse "";

        // 2. Let env be the LexicalEnvironment of the running execution context.
        const env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

        // 3. Let privateEnv be the running execution context's PrivateEnvironment.
        const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

        // 4. Let sourceText be the source text matched by GeneratorExpression.
        const source_text = generator_expression.source_text;

        // 5. Let closure be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
        //    FormalParameters, GeneratorBody, non-lexical-this, env, privateEnv).
        const closure = try ordinaryFunctionCreate(
            agent,
            try realm.intrinsics.@"%GeneratorFunction.prototype%"(),
            source_text,
            generator_expression.formal_parameters,
            generator_expression.function_body,
            .non_lexical_this,
            env,
            private_env,
        );

        // 6. Perform SetFunctionName(closure, name).
        try setFunctionName(closure, PropertyKey.from(name), null);

        // 7. Let prototype be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
        const prototype = try ordinaryObjectCreate(
            agent,
            try realm.intrinsics.@"%GeneratorFunction.prototype.prototype%"(),
        );

        // 8. Perform ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor {
        //      [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false
        //    }).
        closure.definePropertyOrThrow(PropertyKey.from("prototype"), .{
            .value = Value.from(prototype),
            .writable = true,
            .enumerable = false,
            .configurable = false,
        }) catch |err| try noexcept(err);

        // 9. Return closure.
        return closure;
    }
}

/// 15.6.4 Runtime Semantics: InstantiateAsyncGeneratorFunctionExpression
/// https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression
fn instantiateAsyncGeneratorFunctionExpression(
    agent: *Agent,
    async_generator_expression: ast.AsyncGeneratorExpression,
    default_name: ?[]const u8,
) !Object {
    const realm = agent.currentRealm();

    // GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
    if (async_generator_expression.identifier) |identifier| {
        // 1. Assert: name is not present.
        std.debug.assert(default_name == null);

        // 2. Set name to StringValue of BindingIdentifier.
        const name = identifier;

        // 3. Let outerEnv be the running execution context's LexicalEnvironment.
        const outer_env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

        // 4. Let funcEnv be NewDeclarativeEnvironment(outerEnv).
        const func_env = try newDeclarativeEnvironment(agent.gc_allocator, outer_env);

        // 5. Perform ! funcEnv.CreateImmutableBinding(name, false).
        try func_env.createImmutableBinding(agent, name, false);

        // 6. Let privateEnv be the running execution context's PrivateEnvironment.
        const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

        // 7. Let sourceText be the source text matched by AsyncGeneratorExpression.
        const source_text = async_generator_expression.source_text;

        // 8. Let closure be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText,
        //    FormalParameters, AsyncGeneratorBody, non-lexical-this, funcEnv, privateEnv).
        const closure = try ordinaryFunctionCreate(
            agent,
            try realm.intrinsics.@"%AsyncGeneratorFunction.prototype%"(),
            source_text,
            async_generator_expression.formal_parameters,
            async_generator_expression.function_body,
            .non_lexical_this,
            .{ .declarative_environment = func_env },
            private_env,
        );

        // 9. Perform SetFunctionName(closure, name).
        try setFunctionName(closure, PropertyKey.from(name), null);

        // 10. Let prototype be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
        const prototype = try ordinaryObjectCreate(
            agent,
            try realm.intrinsics.@"%AsyncGeneratorFunction.prototype.prototype%"(),
        );

        // 11. Perform ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor {
        //       [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false
        //     }).
        closure.definePropertyOrThrow(PropertyKey.from("prototype"), .{
            .value = Value.from(prototype),
            .writable = true,
            .enumerable = false,
            .configurable = false,
        }) catch |err| try noexcept(err);

        // 12. Perform ! funcEnv.InitializeBinding(name, closure).
        func_env.initializeBinding(agent, name, Value.from(closure));

        // 13. Return closure.
        return closure;
    }
    // AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody }
    else {
        // 1. If name is not present, set name to "".
        const name = default_name orelse "";

        // 2. Let env be the LexicalEnvironment of the running execution context.
        const env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

        // 3. Let privateEnv be the running execution context's PrivateEnvironment.
        const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

        // 4. Let sourceText be the source text matched by AsyncGeneratorExpression.
        const source_text = async_generator_expression.source_text;

        // 5. Let closure be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, sourceText,
        //    FormalParameters, AsyncGeneratorBody, non-lexical-this, env, privateEnv).
        const closure = try ordinaryFunctionCreate(
            agent,
            try realm.intrinsics.@"%AsyncGeneratorFunction.prototype%"(),
            source_text,
            async_generator_expression.formal_parameters,
            async_generator_expression.function_body,
            .non_lexical_this,
            env,
            private_env,
        );

        // 6. Perform SetFunctionName(closure, name).
        try setFunctionName(closure, PropertyKey.from(name), null);

        // 7. Let prototype be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
        const prototype = try ordinaryObjectCreate(
            agent,
            try realm.intrinsics.@"%AsyncGeneratorFunction.prototype.prototype%"(),
        );

        // 8. Perform ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor {
        //      [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false
        //    }).
        closure.definePropertyOrThrow(PropertyKey.from("prototype"), .{
            .value = Value.from(prototype),
            .writable = true,
            .enumerable = false,
            .configurable = false,
        }) catch |err| try noexcept(err);

        // 9. Return closure.
        return closure;
    }
}

/// 15.8.3 Runtime Semantics: InstantiateAsyncFunctionExpression
/// https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncfunctionexpression
fn instantiateAsyncFunctionExpression(
    agent: *Agent,
    async_function_expression: ast.AsyncFunctionExpression,
    default_name: ?[]const u8,
) !Object {
    const realm = agent.currentRealm();

    // AsyncFunctionExpression : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
    if (async_function_expression.identifier) |identifier| {
        // 1. Assert: name is not present.
        std.debug.assert(default_name == null);

        // 2. Set name to StringValue of BindingIdentifier.
        const name = identifier;

        // 3. Let outerEnv be the running execution context's LexicalEnvironment.
        const outer_env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

        // 4. Let funcEnv be NewDeclarativeEnvironment(outerEnv).
        const func_env = try newDeclarativeEnvironment(agent.gc_allocator, outer_env);

        // 5. Perform ! funcEnv.CreateImmutableBinding(name, false).
        try func_env.createImmutableBinding(agent, name, false);

        // 6. Let privateEnv be the running execution context's PrivateEnvironment.
        const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

        // 7. Let sourceText be the source text matched by AsyncFunctionExpression.
        const source_text = async_function_expression.source_text;

        // 8. Let closure be OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
        //    FormalParameters, AsyncFunctionBody, non-lexical-this, funcEnv, privateEnv).
        const closure = try ordinaryFunctionCreate(
            agent,
            try realm.intrinsics.@"%AsyncFunction.prototype%"(),
            source_text,
            async_function_expression.formal_parameters,
            async_function_expression.function_body,
            .non_lexical_this,
            .{ .declarative_environment = func_env },
            private_env,
        );

        // 9. Perform SetFunctionName(closure, name).
        try setFunctionName(closure, PropertyKey.from(name), null);

        // 10. Perform ! funcEnv.InitializeBinding(name, closure).
        func_env.initializeBinding(agent, name, Value.from(closure));

        // 11. Return closure.
        return closure;
    }
    // AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody }
    else {
        // 1. If name is not present, set name to "".
        const name = default_name orelse "";

        // 2. Let env be the LexicalEnvironment of the running execution context.
        const env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

        // 3. Let privateEnv be the running execution context's PrivateEnvironment.
        const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

        // 4. Let sourceText be the source text matched by AsyncFunctionExpression.
        const source_text = async_function_expression.source_text;

        // 5. Let closure be OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
        //    FormalParameters, AsyncFunctionBody, non-lexical-this, env, privateEnv).
        const closure = try ordinaryFunctionCreate(
            agent,
            try realm.intrinsics.@"%AsyncFunction.prototype%"(),
            source_text,
            async_function_expression.formal_parameters,
            async_function_expression.function_body,
            .non_lexical_this,
            env,
            private_env,
        );

        // 6. Perform SetFunctionName(closure, name).
        try setFunctionName(closure, PropertyKey.from(name), null);

        // 7. Return closure.
        return closure;
    }
}

/// 15.9.4 Runtime Semantics: InstantiateAsyncArrowFunctionExpression
/// https://tc39.es/ecma262/#sec-runtime-semantics-instantiateasyncarrowfunctionexpression
fn instantiateAsyncArrowFunctionExpression(
    agent: *Agent,
    async_arrow_function: ast.AsyncArrowFunction,
    default_name: ?[]const u8,
) !Object {
    const realm = agent.currentRealm();

    // 1. If name is not present, set name to "".
    const name = default_name orelse "";

    // 2. Let env be the LexicalEnvironment of the running execution context.
    const env = agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

    // 3. Let privateEnv be the running execution context's PrivateEnvironment.
    const private_env = agent.runningExecutionContext().ecmascript_code.?.private_environment;

    // 4. Let sourceText be the source text matched by AsyncArrowFunction.
    const source_text = async_arrow_function.source_text;

    // 5. Let head be the AsyncArrowHead that is covered by CoverCallExpressionAndAsyncArrowHead.
    // 6. Let parameters be the ArrowFormalParameters of head.
    const parameters = async_arrow_function.formal_parameters;

    // 7. Let closure be OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText, parameters,
    //    AsyncConciseBody, lexical-this, env, privateEnv).
    const closure = try ordinaryFunctionCreate(
        agent,
        try realm.intrinsics.@"%AsyncFunction.prototype%"(),
        source_text,
        parameters,
        async_arrow_function.function_body,
        .lexical_this,
        env,
        private_env,
    );

    // 8. Perform SetFunctionName(closure, name).
    try setFunctionName(closure, PropertyKey.from(name), null);

    // 9. Return closure.
    return closure;
}

pub fn executeInstruction(self: *Self, executable: Executable, instruction: Instruction) !void {
    switch (instruction) {
        .apply_string_or_numeric_binary_operator => {
            const operator_type = self.fetchIndex(executable);
            const operator: ast.BinaryExpression.Operator = @enumFromInt(operator_type);
            const rval = self.stack.pop();
            const lval = self.stack.pop();
            self.result = try applyStringOrNumericBinaryOperator(self.agent, lval, operator, rval);
        },
        .array_create => self.result = Value.from(try arrayCreate(self.agent, 0, null)),
        .array_push_value => {
            const init_value = self.stack.pop();
            const array = self.stack.pop().object;
            const index = getArrayLength(array);
            // From ArrayAccumulation:
            // 4. Perform ! CreateDataPropertyOrThrow(array, ! ToString(ð”½(nextIndex)), initValue).
            array.createDataPropertyOrThrow(
                PropertyKey.from(@as(PropertyKey.IntegerIndex, index)),
                init_value,
            ) catch |err| try noexcept(err);
            self.result = Value.from(array);
        },
        .array_set_length => {
            const length = self.fetchIndex(executable);
            const array = self.result.?.object;
            // From ArrayAccumulation:
            // 2. Perform ? Set(array, "length", ð”½(len), true).
            try array.set(PropertyKey.from("length"), Value.from(length), .throw);
        },
        .bitwise_not => {
            const value = self.result.?;
            self.result = switch (value) {
                .number => |number| Value.from(number.bitwiseNOT()),
                .big_int => |big_int| Value.from(try big_int.bitwiseNOT(self.agent)),
                else => unreachable,
            };
        },
        .create_catch_binding => {
            const name = self.fetchIdentifier(executable);
            const thrown_value = self.exception.?;
            self.exception = null;
            const running_context = self.agent.runningExecutionContext();
            const catch_env = running_context.ecmascript_code.?.lexical_environment;
            try catch_env.createMutableBinding(self.agent, name, false);
            try catch_env.initializeBinding(self.agent, name, thrown_value);
        },
        .decrement => {
            const value = self.result.?;
            self.result = switch (value) {
                .number => |number| Value.from(number.subtract(.{ .i32 = 1 })),
                .big_int => |big_int| Value.from(
                    try big_int.subtract(self.agent, self.agent.pre_allocated.one),
                ),
                else => @panic("decrement instruction must only be used with numeric value"),
            };
        },
        .delete => {
            // NOTE: 1-2. are part of the generated bytecode.
            const reference = self.reference.?;

            // 3. If IsUnresolvableReference(ref) is true, then
            if (reference.isUnresolvableReference()) {
                // a. Assert: ref.[[Strict]] is false.
                std.debug.assert(!reference.strict);

                // b. Return true.
                self.result = Value.from(true);
                return;
            }

            // 4. If IsPropertyReference(ref) is true, then
            if (reference.isPropertyReference()) {
                // a. Assert: IsPrivateReference(ref) is false.
                std.debug.assert(!reference.isPrivateReference());

                // b. If IsSuperReference(ref) is true, throw a ReferenceError exception.
                if (reference.isSuperReference()) {
                    return self.agent.throwException(
                        .reference_error,
                        "Cannot delete super reference",
                    );
                }

                // c. Let baseObj be ? ToObject(ref.[[Base]]).
                const base_obj = try reference.base.value.toObject(self.agent);

                // d. Let deleteStatus be ? baseObj.[[Delete]](ref.[[ReferencedName]]).
                const referenced_name = switch (reference.referenced_name) {
                    .string => |string| PropertyKey.from(string),
                    .symbol => |symbol| PropertyKey.from(symbol),
                    .private_name => unreachable,
                };
                const delete_status = try base_obj.internalMethods().delete(base_obj, referenced_name);

                // e. If deleteStatus is false and ref.[[Strict]] is true, throw a TypeError exception.
                if (!delete_status and reference.strict) {
                    return self.agent.throwException(.type_error, "Could not delete property");
                }

                // f. Return deleteStatus.
                self.result = Value.from(delete_status);
            }
            // 5. Else,
            else {
                // a. Let base be ref.[[Base]].
                // b. Assert: base is an Environment Record.
                const base = reference.base.environment;

                // c. Return ? base.DeleteBinding(ref.[[ReferencedName]]).
                self.result = Value.from(try base.deleteBinding(reference.referenced_name.string));
            }
        },
        .evaluate_call => {
            const maybe_reference = self.reference_stack.getLast();
            const argument_count = self.fetchIndex(executable);
            const strict = self.fetchIndex(executable) == 1;
            var arguments = try std.ArrayList(Value).initCapacity(
                self.agent.gc_allocator,
                argument_count,
            );
            for (0..argument_count) |_| {
                const argument = self.stack.pop();
                try arguments.append(argument);
            }
            std.mem.reverse(Value, arguments.items);
            const this_value = self.stack.pop();
            const function = self.stack.pop();

            const realm = self.agent.currentRealm();
            const eval = try realm.intrinsics.@"%eval%"();

            // 6. If ref is a Reference Record, IsPropertyReference(ref) is false, and
            //    ref.[[ReferencedName]] is "eval", then
            if (maybe_reference) |reference| {
                if (!reference.isPropertyReference() and
                    reference.referenced_name == .string and
                    std.mem.eql(u8, reference.referenced_name.string, "eval") and

                    // a. If SameValue(func, %eval%) is true, then
                    function.object.sameValue(eval))
                {
                    self.result = try directEval(self.agent, arguments.items, strict);
                    return;
                }
            }

            self.result = try evaluateCall(
                self.agent,
                function,
                this_value,
                arguments.items,
            );
        },
        .evaluate_new => {
            const argument_count = self.fetchIndex(executable);
            var arguments = try std.ArrayList(Value).initCapacity(
                self.agent.gc_allocator,
                argument_count,
            );
            defer arguments.deinit();
            for (0..argument_count) |_| {
                const argument = self.stack.pop();
                try arguments.append(argument);
            }
            std.mem.reverse(Value, arguments.items);
            const constructor = self.stack.pop();
            self.result = try evaluateNew(self.agent, constructor, arguments.items);
        },
        // 13.3.3 EvaluatePropertyAccessWithExpressionKey ( baseValue, expression, strict )
        // https://tc39.es/ecma262/#sec-evaluate-property-access-with-expression-key
        .evaluate_property_access_with_expression_key => {
            // 1. Let propertyNameReference be ? Evaluation of expression.
            // 2. Let propertyNameValue be ? GetValue(propertyNameReference).
            const property_name_value = self.stack.pop();

            const strict = self.fetchIndex(executable) == 1;
            const base_value = self.stack.pop();

            // 3. Let propertyKey be ? ToPropertyKey(propertyNameValue).
            const property_key = try property_name_value.toPropertyKey(self.agent);

            // 4. Return the Reference Record {
            //      [[Base]]: baseValue,
            //      [[ReferencedName]]: propertyKey,
            //      [[Strict]]: strict,
            //      [[ThisValue]]: empty
            //    }.
            self.reference = Reference{
                .base = .{ .value = base_value },
                .referenced_name = switch (property_key) {
                    .string => |string| .{ .string = string.utf8 },
                    .symbol => |symbol| .{ .symbol = symbol },
                    .integer_index => |integer_index| .{
                        .string = try std.fmt.allocPrint(
                            self.agent.gc_allocator,
                            "{}",
                            .{integer_index},
                        ),
                    },
                },
                .strict = strict,
                .this_value = null,
            };
        },
        // 13.3.4 EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName, strict )
        // https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key
        .evaluate_property_access_with_identifier_key => {
            // 1. Let propertyNameString be StringValue of identifierName.
            const property_name_string = self.fetchIdentifier(executable);

            const strict = self.fetchIndex(executable) == 1;
            const base_value = self.stack.pop();

            // 2. Return the Reference Record {
            //      [[Base]]: baseValue,
            //      [[ReferencedName]]: propertyNameString,
            //      [[Strict]]: strict,
            //      [[ThisValue]]: empty
            //    }.
            self.reference = Reference{
                .base = .{ .value = base_value },
                .referenced_name = .{ .string = property_name_string },
                .strict = strict,
                .this_value = null,
            };
        },
        .get_new_target => {
            self.result = if (self.agent.getNewTarget()) |new_target|
                Value.from(new_target)
            else
                .undefined;
        },
        .get_value => {
            if (self.reference) |reference| self.result = try reference.getValue(self.agent);
            self.reference = null;
        },
        .greater_than => {
            const rval = self.stack.pop();
            const lval = self.stack.pop();

            // 5. Let r be ? IsLessThan(rval, lval, false).
            const result = try isLessThan(self.agent, rval, lval, .right_first);

            // 6. If r is undefined, return false. Otherwise, return r.
            self.result = Value.from(result orelse false);
        },
        .greater_than_equals => {
            const rval = self.stack.pop();
            const lval = self.stack.pop();

            // 5. Let r be ? IsLessThan(lval, rval, true).
            const result = try isLessThan(self.agent, lval, rval, .left_first);

            // 6. If r is either true or undefined, return false. Otherwise, return true.
            self.result = Value.from(!(result orelse true));
        },
        .has_property => {
            const rval = self.stack.pop();
            const lval = self.stack.pop();

            // 5. If rval is not an Object, throw a TypeError exception.
            if (rval != .object) return self.agent.throwException(
                .type_error,
                "Right-hand side of 'in' operator must be an object",
            );

            // 6. Return ? HasProperty(rval, ? ToPropertyKey(lval)).
            self.result = Value.from(
                try rval.object.hasProperty(try lval.toPropertyKey(self.agent)),
            );
        },
        .increment => {
            const value = self.result.?;
            self.result = switch (value) {
                .number => |number| Value.from(number.add(.{ .i32 = 1 })),
                .big_int => |big_int| Value.from(
                    try big_int.add(self.agent, self.agent.pre_allocated.one),
                ),
                else => @panic("increment instruction must only be used with numeric value"),
            };
        },
        .instanceof_operator => {
            const rval = self.stack.pop();
            const lval = self.stack.pop();

            // 5. Return ? InstanceofOperator(lval, rval).
            self.result = Value.from(try instanceofOperator(self.agent, lval, rval));
        },
        .instantiate_arrow_function_expression => {
            const function_expression = self.fetchFunctionExpression(executable);
            const closure = try instantiateArrowFunctionExpression(
                self.agent,
                function_expression.arrow_function,
                null,
            );
            self.result = Value.from(closure);
        },
        .instantiate_async_arrow_function_expression => {
            const function_expression = self.fetchFunctionExpression(executable);
            const closure = try instantiateAsyncArrowFunctionExpression(
                self.agent,
                function_expression.async_arrow_function,
                null,
            );
            self.result = Value.from(closure);
        },
        .instantiate_async_function_expression => {
            const function_expression = self.fetchFunctionExpression(executable);
            const closure = try instantiateAsyncFunctionExpression(
                self.agent,
                function_expression.async_function_expression,
                null,
            );
            self.result = Value.from(closure);
        },
        .instantiate_async_generator_function_expression => {
            const function_expression = self.fetchFunctionExpression(executable);
            const closure = try instantiateAsyncGeneratorFunctionExpression(
                self.agent,
                function_expression.async_generator_expression,
                null,
            );
            self.result = Value.from(closure);
        },
        .instantiate_generator_function_expression => {
            const function_expression = self.fetchFunctionExpression(executable);
            const closure = try instantiateGeneratorFunctionExpression(
                self.agent,
                function_expression.generator_expression,
                null,
            );
            self.result = Value.from(closure);
        },
        .instantiate_ordinary_function_expression => {
            const function_expression = self.fetchFunctionExpression(executable);
            const closure = try instantiateOrdinaryFunctionExpression(
                self.agent,
                function_expression.function_expression,
                null,
            );
            self.result = Value.from(closure);
        },
        .is_loosely_equal => {
            const rval = self.stack.pop();
            const lval = self.stack.pop();

            // 5. Return IsLooselyEqual(rval, lval).
            self.result = Value.from(try isLooselyEqual(self.agent, rval, lval));
        },
        .is_strictly_equal => {
            const rval = self.stack.pop();
            const lval = self.stack.pop();

            // 5. Return IsStrictlyEqual(rval, lval).
            self.result = Value.from(isStrictlyEqual(rval, lval));
        },
        .jump => self.ip = self.fetchIndex(executable),
        .jump_conditional => {
            const ip_consequent = self.fetchIndex(executable);
            const ip_alternate = self.fetchIndex(executable);
            const value = self.result.?;
            self.ip = if (value.toBoolean()) ip_consequent else ip_alternate;
        },
        .less_than => {
            const rval = self.stack.pop();
            const lval = self.stack.pop();

            // 5. Let r be ? IsLessThan(lval, rval, true).
            const result = try isLessThan(self.agent, lval, rval, .left_first);

            // 6. If r is undefined, return false. Otherwise, return r.
            self.result = Value.from(result orelse false);
        },
        .less_than_equals => {
            const rval = self.stack.pop();
            const lval = self.stack.pop();

            // 5. Let r be ? IsLessThan(rval, lval, false).
            const result = try isLessThan(self.agent, rval, lval, .right_first);

            // 6. If r is either true or undefined, return false. Otherwise, return true.
            self.result = Value.from(!(result orelse true));
        },
        .load => {
            // Handle null value to allow load of 'empty' result at beginning of script
            if (self.result) |value| try self.stack.append(value);
        },
        .load_constant => {
            const value = self.fetchConstant(executable);
            try self.stack.append(value);
        },
        .load_this_value => {
            const maybe_reference = self.reference_stack.getLast();
            const this_value = evaluateCallGetThisValue(maybe_reference);
            try self.stack.append(this_value);
        },
        .logical_not => {
            const value = self.result.?;
            self.result = Value.from(!value.toBoolean());
        },
        .object_create => {
            const object = try ordinaryObjectCreate(
                self.agent,
                try self.agent.currentRealm().intrinsics.@"%Object.prototype%"(),
            );
            self.result = Value.from(object);
        },
        // 15.4.5 Runtime Semantics: MethodDefinitionEvaluation
        // https://tc39.es/ecma262/#sec-runtime-semantics-methoddefinitionevaluation
        .object_define_method => {
            const realm = self.agent.currentRealm();
            const function_expression = self.fetchFunctionExpression(executable);
            const method_definition = function_expression.function_expression;
            const method_type_raw = self.fetchIndex(executable);
            const method_type: ast.MethodDefinition.Type = @enumFromInt(method_type_raw);
            const property_name = self.stack.pop();
            const object = self.stack.pop().object;
            const enumerable = true;

            switch (method_type) {
                // MethodDefinition : ClassElementName ( UniqueFormalParameters ) { FunctionBody }
                .method => {
                    // 1. Let methodDef be ? DefineMethod of MethodDefinition with argument object.
                    const method_def = try defineMethod(
                        self.agent,
                        method_definition,
                        property_name,
                        object,
                        null,
                    );

                    // 2. Perform SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]).
                    try setFunctionName(method_def.closure, method_def.key, null);

                    // 3. Return DefineMethodProperty(object, methodDef.[[Key]], methodDef.[[Closure]], enumerable).
                    try defineMethodProperty(object, method_def.key, method_def.closure, enumerable);
                },

                // MethodDefinition : get ClassElementName ( ) { FunctionBody }
                .get => {
                    // 1. Let propKey be ? Evaluation of ClassElementName.
                    const property_key = try property_name.toPropertyKey(self.agent);

                    // 2. Let env be the running execution context's LexicalEnvironment.
                    const env = self.agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

                    // 3. Let privateEnv be the running execution context's PrivateEnvironment.
                    const private_env = self.agent.runningExecutionContext().ecmascript_code.?.private_environment;

                    // 4. Let sourceText be the source text matched by MethodDefinition.
                    const source_text = method_definition.source_text;

                    // 5. Let formalParameterList be an instance of the production FormalParameters : [empty] .
                    const formal_parameter_list = ast.FormalParameters{ .items = &.{} };

                    // 6. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText,
                    //    formalParameterList, FunctionBody, non-lexical-this, env, privateEnv).
                    const closure = try ordinaryFunctionCreate(
                        self.agent,
                        try realm.intrinsics.@"%Function.prototype%"(),
                        source_text,
                        formal_parameter_list,
                        method_definition.function_body,
                        .non_lexical_this,
                        env,
                        private_env,
                    );

                    // 7. Perform MakeMethod(closure, object).
                    makeMethod(closure.as(builtins.ECMAScriptFunction), object);

                    // 8. Perform SetFunctionName(closure, propKey, "get").
                    try setFunctionName(closure, property_key, "get");

                    // TODO: 9. If propKey is a Private Name, then
                    if (false) {
                        // a. Return PrivateElement { [[Key]]: propKey, [[Kind]]: accessor, [[Get]]: closure, [[Set]]: undefined }.
                    }
                    // 10. Else,
                    else {
                        // a. Let desc be the PropertyDescriptor {
                        //      [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true
                        //    }.
                        const property_descriptor = PropertyDescriptor{
                            .get = closure,
                            .enumerable = enumerable,
                            .configurable = true,
                        };

                        // b. Perform ? DefinePropertyOrThrow(object, propKey, desc).
                        try object.definePropertyOrThrow(property_key, property_descriptor);

                        // c. Return unused.
                    }
                },

                // MethodDefinition : set ClassElementName ( PropertySetParameterList ) { FunctionBody }
                .set => {
                    // 1. Let propKey be ? Evaluation of ClassElementName.
                    const property_key = try property_name.toPropertyKey(self.agent);

                    // 2. Let env be the running execution context's LexicalEnvironment.
                    const env = self.agent.runningExecutionContext().ecmascript_code.?.lexical_environment;

                    // 3. Let privateEnv be the running execution context's PrivateEnvironment.
                    const private_env = self.agent.runningExecutionContext().ecmascript_code.?.private_environment;

                    // 4. Let sourceText be the source text matched by MethodDefinition.
                    const source_text = method_definition.source_text;

                    // 5. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText,
                    //    PropertySetParameterList, FunctionBody, non-lexical-this, env, privateEnv).
                    const closure = try ordinaryFunctionCreate(
                        self.agent,
                        try realm.intrinsics.@"%Function.prototype%"(),
                        source_text,
                        method_definition.formal_parameters,
                        method_definition.function_body,
                        .non_lexical_this,
                        env,
                        private_env,
                    );

                    // 6. Perform MakeMethod(closure, object).
                    makeMethod(closure.as(builtins.ECMAScriptFunction), object);

                    // 7. Perform SetFunctionName(closure, propKey, "set").
                    try setFunctionName(closure, property_key, "set");

                    // TODO: 8. If propKey is a Private Name, then
                    if (false) {
                        // a. Return PrivateElement { [[Key]]: propKey, [[Kind]]: accessor, [[Get]]: undefined, [[Set]]: closure }.
                    }
                    // 9. Else,
                    else {
                        // a. Let desc be the PropertyDescriptor {
                        //      [[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true
                        //    }.
                        const property_descriptor = PropertyDescriptor{
                            .set = closure,
                            .enumerable = enumerable,
                            .configurable = true,
                        };

                        // b. Perform ? DefinePropertyOrThrow(object, propKey, desc).
                        try object.definePropertyOrThrow(property_key, property_descriptor);

                        // c. Return unused.
                    }
                },
            }

            self.result = Value.from(object);
        },
        .object_set_property => {
            const property_value = self.stack.pop();
            const property_name = try self.stack.pop().toPropertyKey(self.agent);
            const object = self.stack.pop().object;
            // From PropertyDefinitionEvaluation:
            // 5. Perform ! CreateDataPropertyOrThrow(object, propName, propValue).
            object.createDataPropertyOrThrow(property_name, property_value) catch |err| try noexcept(err);
            self.result = Value.from(object);
        },
        .pop_exception_jump_target => _ = self.exception_jump_target_stack.pop(),
        .pop_reference => _ = self.reference_stack.pop(),
        .push_exception_jump_target => {
            const jump_target = self.fetchIndex(executable);
            try self.exception_jump_target_stack.append(jump_target);
        },
        .push_reference => try self.reference_stack.append(self.reference),
        .put_value => {
            const lref = self.reference_stack.getLast().?;
            const rval = self.result.?;
            try lref.putValue(self.agent, rval);
            self.reference = null;
        },
        .reg_exp_create => {
            const flags = self.stack.pop();
            const pattern = self.stack.pop();
            self.result = Value.from(try builtins.regExpCreate(self.agent, pattern, flags));
        },
        .resolve_binding => {
            const name = self.fetchIdentifier(executable);
            const strict = self.fetchIndex(executable) == 1;
            self.reference = try self.agent.resolveBinding(name, null, strict);
        },
        .resolve_this_binding => self.result = try self.agent.resolveThisBinding(),
        .rethrow_exception_if_any => if (self.exception) |value| {
            self.agent.exception = value;
            return error.ExceptionThrown;
        },
        .@"return" => {}, // Handled in run()
        .store => {
            // Handle empty stack to allow restoring a null `.load`
            self.result = self.stack.popOrNull();
        },
        .store_constant => {
            const value = self.fetchConstant(executable);
            self.result = value;
        },
        .throw => {
            const value = self.result.?;
            self.agent.exception = value;
            return error.ExceptionThrown;
        },
        .to_number => {
            const value = self.result.?;
            self.result = Value.from(try value.toNumber(self.agent));
        },
        .to_numeric => {
            const value = self.result.?;
            const numeric = try value.toNumeric(self.agent);
            self.result = switch (numeric) {
                .number => |number| Value.from(number),
                .big_int => |big_int| Value.from(big_int),
            };
        },
        .typeof => {
            // 1. Let val be ? Evaluation of UnaryExpression.
            // NOTE: This is part of the generated bytecode.

            // 2. If val is a Reference Record, then
            if (self.reference) |reference| {
                // a. If IsUnresolvableReference(val) is true, return "undefined".
                if (reference.isUnresolvableReference()) {
                    self.result = Value.from("undefined");
                    return;
                }
            }

            // 3. Set val to ? GetValue(val).
            const value = if (self.reference) |reference|
                try reference.getValue(self.agent)
            else
                self.result.?;

            self.result = switch (value) {
                // 4. If val is undefined, return "undefined".
                .undefined => Value.from("undefined"),

                // 5. If val is null, return "object".
                .null => Value.from("object"),

                // 6. If val is a String, return "string".
                .string => Value.from("string"),

                // 7. If val is a Symbol, return "symbol".
                .symbol => Value.from("symbol"),

                // 8. If val is a Boolean, return "boolean".
                .boolean => Value.from("boolean"),

                // 9. If val is a Number, return "number".
                .number => Value.from("number"),

                // 10. If val is a BigInt, return "bigint".
                .big_int => Value.from("bigint"),

                // 11. Assert: val is an Object.
                .object => |object| blk: {
                    // 12. NOTE: This step is replaced in section B.3.6.3.

                    // 13. If val has a [[Call]] internal slot, return "function".
                    if (object.internalMethods().call) |_| break :blk Value.from("function");

                    // 14. Return "object".
                    break :blk Value.from("object");
                },
            };
        },
        .unary_minus => {
            const value = self.result.?;
            self.result = switch (value) {
                .number => |number| Value.from(number.unaryMinus()),
                .big_int => |big_int| Value.from(try big_int.unaryMinus()),
                else => unreachable,
            };
        },
        _ => unreachable,
    }
}

pub fn run(self: *Self, executable: Executable) !Completion {
    while (self.fetchInstruction(executable)) |instruction| {
        self.executeInstruction(executable, instruction) catch |err| {
            if (self.exception_jump_target_stack.items.len != 0) {
                self.exception = self.agent.exception;
                self.agent.exception = null;
                self.ip = self.exception_jump_target_stack.getLast();
            } else return err;
        };
        if (instruction == .@"return") {
            return .{ .type = .@"return", .value = self.result, .target = null };
        }
    }
    return Completion.normal(self.result);
}
