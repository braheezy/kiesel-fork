const std = @import("std");

const builtins = @import("../../builtins.zig");
const execution = @import("../../execution.zig");
const instructions_ = @import("instructions.zig");
const types = @import("../../types.zig");

const Agent = execution.Agent;
const Executable = @import("Executable.zig");
const Instruction = instructions_.Instruction;
const Reference = types.Reference;
const Value = types.Value;
const performEval = builtins.performEval;

const Self = @This();

agent: *Agent,
ip: usize,
stack: std.ArrayList(Value),
result: ?Value,
last_reference: ?Reference = null,
evaluation_context: EvaluationContext,

const EvaluationContext = struct {
    reference: ?Reference = null,
};

pub fn init(agent: *Agent) !Self {
    var stack = try std.ArrayList(Value).initCapacity(agent.gc_allocator, 32);
    return .{
        .agent = agent,
        .ip = 0,
        .stack = stack,
        .result = null,
        .last_reference = null,
        .evaluation_context = .{},
    };
}

pub fn deinit(self: Self) void {
    self.stack.deinit();
}

fn fetchInstruction(self: *Self, executable: Executable) ?Instruction {
    const instructions = executable.instructions.items;
    if (self.ip >= instructions.len) return null;
    defer self.ip += 1;
    return instructions[self.ip];
}

fn fetchConstant(self: *Self, executable: Executable) Value {
    const constants = executable.constants.items;
    const index = self.fetchIndex(executable);
    return constants[index];
}

fn fetchIdentifier(self: *Self, executable: Executable) []const u8 {
    const identifiers = executable.identifiers.items;
    const index = self.fetchIndex(executable);
    return identifiers[index];
}

fn fetchIndex(self: *Self, executable: Executable) Executable.IndexType {
    const b1 = @enumToInt(self.fetchInstruction(executable).?);
    const b2 = @enumToInt(self.fetchInstruction(executable).?);
    return std.mem.bytesToValue(Executable.IndexType, &[_]u8{ b1, b2 });
}

/// 13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )
/// https://tc39.es/ecma262/#sec-evaluatecall
fn evaluateCallGetThisValue(ctx: EvaluationContext) Value {
    // 1. If ref is a Reference Record, then
    if (ctx.reference) |reference| {
        // a. If IsPropertyReference(ref) is true, then
        if (reference.isPropertyReference()) {
            // i. Let thisValue be GetThisValue(ref).
            return reference.getThisValue();
        }
        // b. Else,
        else {
            // i. Let refEnv be ref.[[Base]].
            // ii. Assert: refEnv is an Environment Record.
            const reference_environment = reference.base.environment;

            // iii. Let thisValue be refEnv.WithBaseObject().
            return if (reference_environment.withBaseObject()) |object|
                Value.from(object)
            else
                .undefined;
        }
    }
    // 2. Else,
    else {
        // a. Let thisValue be undefined.
        return .undefined;
    }
}

/// 13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )
/// https://tc39.es/ecma262/#sec-evaluatecall
fn evaluateCall(
    agent: *Agent,
    function: Value,
    this_value: Value,
    arguments: []const Value,
) !Value {
    // 1-2.
    // NOTE: These are done in the function above, which is called by the prepare_call instruction.

    // 3. Let argList be ? ArgumentListEvaluation of arguments.
    // NOTE: This is part of the generated bytecode.

    // 4. If func is not an Object, throw a TypeError exception.
    if (function != .object) {
        return agent.throwException(
            .type_error,
            try std.fmt.allocPrint(agent.gc_allocator, "{} is not an Object", .{function}),
        );
    }

    // 5. If IsCallable(func) is false, throw a TypeError exception.
    if (!function.isCallable()) {
        return agent.throwException(
            .type_error,
            try std.fmt.allocPrint(agent.gc_allocator, "{} is not callable", .{function}),
        );
    }

    // TODO: 6. If tailPosition is true, perform PrepareForTailCall().

    // 7. Return ? Call(func, thisValue, argList).
    return function.callAssumeCallable(this_value, arguments);
}

/// CallExpression : CoverCallExpressionAndAsyncArrowHead
/// Step 6.a.
fn directEval(agent: *Agent, arguments: []const Value) !Value {
    // i. Let argList be ? ArgumentListEvaluation of arguments.
    // NOTE: This is part of the generated bytecode.

    // ii. If argList has no elements, return undefined.
    if (arguments.len == 0) return .undefined;

    // iii. Let evalArg be the first element of argList.
    const eval_arg = arguments[0];

    // TODO: iv. If the source text matched by this CallExpression is strict mode code, let
    //     strictCaller be true. Otherwise let strictCaller be false.
    const strict_caller = false;

    // v. Return ? PerformEval(evalArg, strictCaller, true).
    return performEval(agent, eval_arg, strict_caller, true);
}

pub fn run(self: *Self, executable: Executable) !?Value {
    while (self.fetchInstruction(executable)) |instruction| switch (instruction) {
        .evaluate_call => {
            defer self.evaluation_context = .{};
            const argument_count = self.fetchIndex(executable);
            var arguments = try std.ArrayList(Value).initCapacity(
                self.agent.gc_allocator,
                argument_count,
            );
            for (0..argument_count) |_| {
                const argument = self.stack.pop();
                try arguments.append(argument);
            }
            std.mem.reverse(Value, arguments.items);
            const this_value = self.stack.pop();
            const function = self.stack.pop();

            const realm = self.agent.currentRealm();
            const eval = try realm.intrinsics.@"%eval%"();

            // 6. If ref is a Reference Record, IsPropertyReference(ref) is false, and
            //    ref.[[ReferencedName]] is "eval", then
            if (self.evaluation_context.reference) |reference| {
                if (!reference.isPropertyReference() and
                    reference.referenced_name == .string and
                    std.mem.eql(u8, reference.referenced_name.string, "eval") and

                    // a. If SameValue(func, %eval%) is true, then
                    function.object.ptr == eval.ptr)
                {
                    self.result = try directEval(self.agent, arguments.items);
                    continue;
                }
            }

            self.result = try evaluateCall(
                self.agent,
                function,
                this_value,
                arguments.items,
            );
        },
        // 13.3.3 EvaluatePropertyAccessWithExpressionKey ( baseValue, expression, strict )
        // https://tc39.es/ecma262/#sec-evaluate-property-access-with-expression-key
        .evaluate_property_access_with_expression_key => {
            // 1. Let propertyNameReference be ? Evaluation of expression.
            // 2. Let propertyNameValue be ? GetValue(propertyNameReference).
            const property_name_value = self.stack.pop();

            const strict = self.fetchIndex(executable) == 1;
            const base_value = self.stack.pop();

            // 3. Let propertyKey be ? ToPropertyKey(propertyNameValue).
            const property_key = try property_name_value.toPropertyKey(self.agent);

            // 4. Return the Reference Record {
            //      [[Base]]: baseValue,
            //      [[ReferencedName]]: propertyKey,
            //      [[Strict]]: strict,
            //      [[ThisValue]]: empty
            //    }.
            const reference = Reference{
                .base = .{ .value = base_value },
                .referenced_name = switch (property_key) {
                    .string => |string| .{ .string = string },
                    .symbol => |symbol| .{ .symbol = symbol },
                    .integer_index => |integer_index| .{
                        .string = try std.fmt.allocPrint(
                            self.agent.gc_allocator,
                            "{}",
                            .{integer_index},
                        ),
                    },
                },
                .strict = strict,
                .this_value = null,
            };
            self.result = try reference.getValue(self.agent);
            self.last_reference = reference;
        },
        // 13.3.4 EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName, strict )
        // https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key
        .evaluate_property_access_with_identifier_key => {
            // 1. Let propertyNameString be StringValue of identifierName.
            const property_name_string = self.fetchIdentifier(executable);

            const strict = self.fetchIndex(executable) == 1;
            const base_value = self.stack.pop();

            // 2. Return the Reference Record {
            //      [[Base]]: baseValue,
            //      [[ReferencedName]]: propertyNameString,
            //      [[Strict]]: strict,
            //      [[ThisValue]]: empty
            //    }.
            const reference = Reference{
                .base = .{ .value = base_value },
                .referenced_name = .{ .string = property_name_string },
                .strict = strict,
                .this_value = null,
            };
            self.result = try reference.getValue(self.agent);
            self.last_reference = reference;
        },
        .jump => self.ip = self.fetchIndex(executable),
        .jump_conditional => {
            const ip_consequent = self.fetchIndex(executable);
            const ip_alternate = self.fetchIndex(executable);
            const value = self.stack.pop();
            self.ip = if (value.toBoolean()) ip_consequent else ip_alternate;
        },
        .load => try self.stack.append(self.result.?),
        .load_constant => {
            const value = self.fetchConstant(executable);
            try self.stack.append(value);
        },
        .load_this_value => {
            const this_value = evaluateCallGetThisValue(self.evaluation_context);
            try self.stack.append(this_value);
        },
        .resolve_binding => {
            const name = self.fetchIdentifier(executable);
            const reference = try self.agent.resolveBinding(name, null);
            self.result = try reference.getValue(self.agent);
            self.last_reference = reference;
        },
        .resolve_this_binding => self.result = try self.agent.resolveThisBinding(),
        .set_reference => {
            const expression_is_reference = self.fetchIndex(executable) == 1;
            self.evaluation_context.reference = if (expression_is_reference)
                self.last_reference.?
            else
                null;
        },
        .store => self.result = self.stack.pop(),
        .store_constant => {
            const value = self.fetchConstant(executable);
            self.result = value;
        },
        .throw => {
            const value = self.stack.pop();
            self.agent.exception = value;
            // TODO: This will need to change when try/catch are implemented.
            return error.ExceptionThrown;
        },
        _ => unreachable,
    };
    return self.result;
}
