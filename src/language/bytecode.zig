const std = @import("std");

const codegen = @import("bytecode/codegen.zig");
const execution = @import("../execution.zig");
const instructions = @import("bytecode/instructions.zig");
const types = @import("../types.zig");

const Agent = execution.Agent;
const Completion = types.Completion;

pub const Executable = @import("bytecode/Executable.zig");
pub const Instruction = instructions.Instruction;
pub const InstructionIterator = instructions.InstructionIterator;
pub const Vm = @import("bytecode/Vm.zig");

test {
    _ = instructions;

    _ = Executable;
    _ = Vm;
}

pub const Options = struct {
    contained_in_strict_mode_code: bool = false,
};

pub fn generateBytecode(
    agent: *Agent,
    ast_node: anytype,
    options: Options,
) Agent.Error!Executable {
    var executable = Executable.init(agent.gc_allocator);

    var ctx = codegen.Context.init();
    defer ctx.deinit(executable.allocator);
    ctx.contained_in_strict_mode_code = options.contained_in_strict_mode_code;

    const ast_node_name = comptime blk: {
        var it = std.mem.splitBackwardsScalar(u8, @typeName(@TypeOf(ast_node)), '.');
        break :blk it.first();
    };
    const codegenFn = @field(codegen, "codegen" ++ ast_node_name);
    codegenFn(ast_node, &executable, &ctx) catch |err| switch (err) {
        error.IndexOutOfRange => return agent.throwException(
            .internal_error,
            "Bytecode generation failed",
            .{},
        ),
        error.OutOfMemory => return error.OutOfMemory,
    };

    // The VM requires this to be the last instruction.
    try executable.addInstruction(.end);

    // Already incremented by one by the last caller
    try executable.environment_lookup_cache.resize(executable.allocator, ctx.environment_lookup_cache_index);
    @memset(executable.environment_lookup_cache.items, null);
    try executable.property_lookup_cache.resize(executable.allocator, ctx.property_lookup_cache_index);
    @memset(executable.property_lookup_cache.items, null);

    if (agent.options.debug.print_bytecode) {
        const stdout = agent.platform.stdout;
        const tty_config = agent.platform.tty_config;
        stdout.writeAll("Generated Bytecode\n") catch {};
        stdout.writeAll("------------------\n") catch {};
        executable.print(stdout, tty_config) catch {};
        stdout.writeAll("\n") catch {};
    }

    return executable;
}

pub fn generateAndRunBytecode(
    agent: *Agent,
    ast_node: anytype,
    options: Options,
) Agent.Error!Completion {
    var executable = try generateBytecode(agent, ast_node, options);
    defer executable.deinit();

    var vm = try Vm.init(agent);
    defer vm.deinit();
    return vm.run(executable);
}
