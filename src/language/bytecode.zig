const std = @import("std");

const ast = @import("ast.zig");
const codegen = @import("bytecode/codegen.zig");
const execution = @import("../execution.zig");
const instructions = @import("bytecode/instructions.zig");
const types = @import("../types.zig");

const Agent = execution.Agent;
const Completion = types.Completion;

pub const Executable = @import("bytecode/Executable.zig");
pub const Instruction = instructions.Instruction;
pub const InstructionIterator = instructions.InstructionIterator;
pub const Vm = @import("bytecode/Vm.zig");

test {
    _ = instructions;

    _ = Executable;
    _ = Vm;
}

pub const Options = struct {
    contained_in_strict_mode_code: bool = false,
};

pub fn generateBytecode(
    agent: *Agent,
    ast_node: anytype,
    options: Options,
) Agent.Error!Executable {
    var executable = Executable.init(agent.gc_allocator);

    var continue_jumps = std.ArrayList(Executable.JumpIndex).init(agent.gc_allocator);
    defer continue_jumps.deinit();
    var break_jumps = std.ArrayList(Executable.JumpIndex).init(agent.gc_allocator);
    defer break_jumps.deinit();

    var ctx = codegen.Context{
        .agent = agent,
        .contained_in_strict_mode_code = options.contained_in_strict_mode_code,
        .continue_jumps = continue_jumps,
        .break_jumps = break_jumps,
    };

    const ast_node_name = comptime blk: {
        var it = std.mem.splitBackwardsScalar(u8, @typeName(@TypeOf(ast_node)), '.');
        break :blk it.first();
    };
    const codegenFn = @field(codegen, "codegen" ++ ast_node_name);
    codegenFn(ast_node, &executable, &ctx) catch |err| switch (err) {
        error.IndexOutOfRange => return agent.throwException(
            .internal_error,
            "Bytecode generation failed",
            .{},
        ),
        error.OutOfMemory => return error.OutOfMemory,
    };

    // Already incremented by one by the last caller
    executable.environment_lookup_cache_size = ctx.environment_lookup_cache_index;

    if (agent.options.debug.print_bytecode) {
        const stdout = std.io.getStdOut().writer();
        stdout.writeAll("Generated Bytecode\n") catch {};
        stdout.writeAll("------------------\n") catch {};
        executable.print(stdout) catch {};
        stdout.writeAll("\n") catch {};
    }

    return executable;
}

pub fn generateAndRunBytecode(
    agent: *Agent,
    ast_node: anytype,
    options: Options,
) Agent.Error!Completion {
    var executable = try generateBytecode(agent, ast_node, options);
    defer executable.deinit();

    var vm = try Vm.init(agent);
    defer vm.deinit();
    return vm.run(executable);
}
