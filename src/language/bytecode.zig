const std = @import("std");

const ast = @import("ast.zig");
const execution = @import("../execution.zig");
const types = @import("../types.zig");

const Agent = execution.Agent;
const Value = types.Value;

const instructions = @import("bytecode/instructions.zig");

pub const Executable = @import("bytecode/Executable.zig");
pub const Instruction = instructions.Instruction;
pub const InstructionIterator = instructions.InstructionIterator;
pub const Vm = @import("bytecode/Vm.zig");

test {
    _ = instructions;

    _ = Executable;
    _ = Vm;
}

pub fn generateAndRunBytecode(agent: *Agent, script: ast.Script) Agent.Error!?Value {
    var vm = try Vm.init(agent);
    defer vm.deinit();

    var executable = Executable.init(agent.gc_allocator);
    defer executable.deinit();

    script.generateBytecode(&executable) catch |err| switch (err) {
        error.IndexOutOfRange => return agent.throwException(
            .internal_error,
            "Bytecode generation failed",
        ),
        error.OutOfMemory => return error.OutOfMemory,
    };

    if (agent.options.debug.print_bytecode) {
        const stdout = std.io.getStdOut().writer();
        stdout.writeAll("Generated Bytecode\n") catch {};
        stdout.writeAll("------------------\n") catch {};
        executable.print(stdout) catch {};
        stdout.writeAll("\n") catch {};
    }

    try executable.optimize();
    if (agent.options.debug.print_bytecode) {
        const stdout = std.io.getStdOut().writer();
        stdout.writeAll("Optimized Bytecode\n") catch {};
        stdout.writeAll("------------------\n") catch {};
        executable.print(stdout) catch {};
        stdout.writeAll("\n") catch {};
    }

    return vm.run(executable);
}
