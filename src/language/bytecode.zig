const std = @import("std");

const ast = @import("ast.zig");
const execution = @import("../execution.zig");
const types = @import("../types.zig");

const Agent = execution.Agent;
const Completion = types.Completion;

const instructions = @import("bytecode/instructions.zig");

pub const Executable = @import("bytecode/Executable.zig");
pub const Instruction = instructions.Instruction;
pub const InstructionIterator = instructions.InstructionIterator;
pub const Vm = @import("bytecode/Vm.zig");

test {
    _ = instructions;

    _ = Executable;
    _ = Vm;
}

pub fn generateAndRunBytecode(agent: *Agent, ast_node: anytype) Agent.Error!Completion {
    var vm = try Vm.init(agent);
    defer vm.deinit();

    var executable = Executable.init(agent.gc_allocator);
    defer executable.deinit();

    var continue_jumps = std.ArrayList(Executable.JumpIndex).init(agent.gc_allocator);
    defer continue_jumps.deinit();

    var ctx = ast.BytecodeContext{
        .agent = agent,
        .contained_in_strict_mode_code = false,
        .continue_jumps = continue_jumps,
    };
    ast_node.generateBytecode(&executable, &ctx) catch |err| switch (err) {
        error.IndexOutOfRange => return agent.throwException(
            .internal_error,
            "Bytecode generation failed",
        ),
        error.OutOfMemory => return error.OutOfMemory,
    };

    if (agent.options.debug.print_bytecode) {
        const stdout = std.io.getStdOut().writer();
        stdout.writeAll("Generated Bytecode\n") catch {};
        stdout.writeAll("------------------\n") catch {};
        executable.print(stdout) catch {};
        stdout.writeAll("\n") catch {};
    }

    try executable.optimize();
    if (agent.options.debug.print_bytecode) {
        const stdout = std.io.getStdOut().writer();
        stdout.writeAll("Optimized Bytecode\n") catch {};
        stdout.writeAll("------------------\n") catch {};
        executable.print(stdout) catch {};
        stdout.writeAll("\n") catch {};
    }

    return vm.run(executable);
}
